<!DOCTYPE html>
<html lang="en">
<head>
<title>THREE.SimpleDatGui Oculus Rift Demo</title>
<meta charset="utf-8">
<style>
body {
	margin: 0px;
	background-color: #000;
	overflow: hidden;
}

.absoluteTitle {
	position: absolute;
	bottom: 0px;
	left: 0px;
	color: #999;
	font-family: Arial;
	font-size: 9pt;
	text-align: left;
	padding-left: 10px;
	padding-right: 10px;
	padding-bottom: 15px;
}
</style>
</head>
<body>
<script src="./lib/three.min.js"></script>
<script src="./lib/TrackballControls.js"></script>
<script src="./lib/stats.min.js"></script>
<script src="./lib/gentilis_regular.typeface.js"></script>
<script src="./lib/optimer_regular.typeface.js"></script>
<script src="./lib/helvetiker_regular.typeface.js"></script>
<script src="./lib/OculusRiftEffect.js"></script>
<script src="./THREE.SimpleDatGui.js"></script>
<script src="./THREE.OculusRiftMousePointerHelper.js"></script>
<script src="./THREE.OculusRiftRotationControls.js"></script>
<div class="absoluteTitle">THREE.SimpleDatGui is rendered in WebGL based on three.js without any other 3rd party library. You may use your mouse wheel to zoom and the left mouse button to rotate the scene. A click with the right mouse button resets the position of the scene. Read more <a href="http://www.sw-engineering-candies.com/blog-1/three-simpledatgui-a-simple-user-interface-for-webgl-with-the-look-feel-of-dat-gui">here</a>.
</div>
<script>
    var controlOculus, effect, camera, scene, renderer, mesh, gui, trackbarControl, container, hemiLight, oculusRiftMousePointerHelper;

    function myOptionsDefinition() {
        "use strict";
        return {
                    RENDER_TEXT: "Hello World!",
                    TRANPARENT: false,
                    ROTATION_SPEED: 2.5,
                    ROTATION_ANGLE: 0.0,
                    FONT_SIZE: 150,
                    ROTATION_X_AXIS: true,
                    OPACITY: 100,
                    FONT_NAME: "Gentilis"
        };
    }
    var myOptions = myOptionsDefinition();

    var guiDefaultWidth = 300;
    var guiBorderTop = 10;
    var guiBorderRight = 10;
    var guiBorderLeft = 10;
    var guiHudModus = !(document.location.search === "?hud=false");

    var sceneDistance = 700;

    init();
    animate();

    function init() {
        "use strict";

        // Prepare scene 

        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setClearColor(0x444444);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.autoClear = false;
        document.body.appendChild(renderer.domElement);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, sceneDistance));
        camera.lookAt(new THREE.Vector3(0, 0, 0));

        scene = new THREE.Scene();
        scene.add(camera);

        effect = new THREE.OculusRiftEffect(renderer);
        effect.setSize(window.innerWidth, window.innerHeight);

        // Add lights

        var light1 = new THREE.PointLight(0xFFFFFF);
        light1.position.set(-300, 300, 2 * camera.position.z);
        light1.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add(light1);

        var light2 = new THREE.PointLight(0xFFFFFF);
        light2.position.set(0, 0, -camera.position.z);
        light2.lookAt(new THREE.Vector3(0, 0, 0));
        scene.add(light2);

        // Add content 

        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);

        // Add GUI

        var myFunctions = {
            RESET_EVENT: function() {
                trackbarControl.reset();
                camera.position.x = 0;
                camera.position.y = 0;
                camera.position.z = sceneDistance;
                camera.rotation.x = 0;
                camera.rotation.y = 0;
                camera.rotation.z = 0;
                camera.lookAt(new THREE.Vector3(0, 0, 0));
            }
        };

        gui = new THREE.SimpleDatGui({
                    scene: scene,
                    camera: camera,
                    renderer: renderer,
                    width: 280,
                    scale: 1.0,
                    position: new THREE.Vector3(-140, 80, 400)
        });

        oculusRiftMousePointerHelper = new THREE.OculusRiftMousePointerHelper({
                    camera: camera,
                    domElement: renderer.domElement
        });
        scene.add(oculusRiftMousePointerHelper);

        gui.add(myFunctions, 'RESET_EVENT').name('Reset Position');
        gui.add(myOptions, 'TRANPARENT').name('Tranparent').onChange(function(value) {
            myOptions.OPACITY = (value) ? 80 : 100;
        });
        gui.add(myOptions, 'OPACITY', 10, 100).step(10).name('Opacity').onChange(function(value) {
            myOptions.TRANPARENT = !(value == 100);
        });
        gui.add(myOptions, 'RENDER_TEXT').name('Render Text').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        gui.add(myOptions, 'FONT_NAME', ['Helvetiker', 'Gentilis', 'Optimer']).name('Font Type').onChange(
                    function(value) {
                        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
                    });

        var folder1 = gui.addFolder("Advanced Options");
        folder1.add(myOptions, 'FONT_SIZE', {
                    Small: 80,
                    Medium: 150,
                    Large: 180,
                    Huge: 300
        }).name('Font Size').onChange(function(value) {
            addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
        });
        folder1.add(myOptions, 'ROTATION_SPEED', -5, 5).step(0.5).name('Rotation Speed');
        folder1.add(myOptions, 'ROTATION_ANGLE', 0, Math.PI * 2).step(0.1).name('Rotation Angle').onChange(
                    function(value) {
                        mesh.rotation.x = myOptions.ROTATION_ANGLE;
                        addOrUpdateRotatingText(scene, myOptions.RENDER_TEXT);
                    });
        folder1.add(myOptions, 'ROTATION_X_AXIS').name('Rotation Active');
        folder1.open();

        // Add event listeners
        window.addEventListener('resize', onWindowResize, false);

        renderer.domElement.addEventListener('mousedown', function(event) {
            if (event.which == 3) {
                myFunctions.RESET_EVENT();
            }
        });

        trackbarControl = new THREE.TrackballControls(camera, renderer.domElement);

        controlOculus = new THREE.OculusRiftRotationControls(camera);

        // Mouse Pointer

        onWindowResize();

        var updateTimerImport = setInterval(function() {
            trackbarControl.update();
            controlOculus.update();
        }, 50);
    }

    function onWindowResize() {
        "use strict";

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        effect.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        "use strict";

        requestAnimationFrame(animate);

        gui.setOpacity(myOptions.OPACITY);
        gui.update();

        oculusRiftMousePointerHelper.update();

        if (myOptions.ROTATION_X_AXIS) {
            mesh.rotation.x = (mesh.rotation.x + 0.005 * myOptions.ROTATION_SPEED) % (Math.PI * 2);
            myOptions.ROTATION_ANGLE = mesh.rotation.x;
        }

        effect.render(scene, camera);
    }

    function addOrUpdateRotatingText(scene, value) {
        "use strict";

        var oldRotationX = 0;

        if (typeof mesh !== "undefined") {
            oldRotationX = mesh.rotation.x;
            scene.remove(mesh);
        }

        if (typeof myOptions.FONT_NAME === "undefined") {
            console.log("myOptions.FONT_NAME === undefined");
        }

        var geometry = new THREE.TextGeometry(myOptions.RENDER_TEXT, {
                    height: myOptions.FONT_SIZE / 10,
                    size: myOptions.FONT_SIZE,
                    font: myOptions.FONT_NAME.toLowerCase()
        });
        var material = new THREE.MeshPhongMaterial({
            color: 0x1ed36f
        });
        mesh = new THREE.Mesh(geometry, material);

        mesh.rotation.x = oldRotationX;

        geometry.computeBoundingBox();
        geometry.textWidth = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
        mesh.translateX(-geometry.textWidth / 2);

        scene.add(mesh);
    }
</script>
</body>
</html>
